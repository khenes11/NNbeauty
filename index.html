<!DOCTYPE html>
<html lang="tr">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
  <title>Saloon N&N Beauty Game</title>
  <style>
    :root {
      --mint:#4ecdc4;
      --mint-dark:#44a08d;
      --bg1:#1a1a2e; --bg2:#16213e;
      --text:#fff; --muted:#bbb;
      --danger:#ff6b6b;
      --panel:#1a1a2e;
    }
    * { box-sizing: border-box; }
    body {
      margin:0; padding:0;
      background: linear-gradient(135deg, var(--bg1), var(--bg2));
      font-family: Arial, sans-serif; color: var(--text);
      display:flex; flex-direction:column; align-items:center; justify-content:center;
      min-height:100vh; overflow-x:hidden;
    }
    .game-container { text-align:center; padding:20px; max-width:95vw; }
    .logo { font-size:2rem; font-weight:bold; margin-bottom:6px; letter-spacing:1px; }
    .nn { color: var(--mint); }
    .game-info {
      display:flex; justify-content:space-around; gap:8px; margin:10px 0; font-size:1rem; font-weight:bold;
    }
    .info-item { background: rgba(78,205,196,.2); padding:5px 10px; border-radius:10px; border:2px solid var(--mint); }
    #gameCanvas {
      border:3px solid var(--mint); border-radius:10px; background:#000;
      display:block; margin:12px auto; width:90vw; max-width:420px; height:auto;
      aspect-ratio: 400 / 250;
      touch-action:none;
    }
    .controls {
      display:grid; grid-template-columns: 1fr 1fr 1fr; grid-template-rows: 1fr 1fr 1fr;
      gap:10px; max-width:180px; margin:12px auto;
    }
    .btn {
      width:52px; height:52px; background:var(--mint); border:none; border-radius:50%;
      color:#000; font-size:1.2rem; cursor:pointer; display:flex; align-items:center; justify-content:center; font-weight:bold;
      box-shadow: 0 4px 12px rgba(0,0,0,.25);
    }
    .btn:active { background: var(--mint-dark); transform: translateY(1px); }
    .up { grid-column:2; grid-row:1; } .left { grid-column:1; grid-row:2; }
    .right { grid-column:3; grid-row:2; } .down { grid-column:2; grid-row:3; }
    #startBtn, #pauseBtn {
      background: var(--mint); border:none; color:#000; padding:12px 20px; font-size:1rem; border-radius:18px; cursor:pointer; font-weight:bold; margin:6px;
    }
    #startBtn:active, #pauseBtn:active { background: var(--mint-dark); }
    .website-link { margin-top:10px; }
    .website-link a {
      color: var(--mint); text-decoration:none; font-weight:bold; padding:8px 15px; border:2px solid var(--mint); border-radius:15px;
    }
    .modal {
      position:fixed; inset:0; width:100%; height:100%;
      background: rgba(0,0,0,.9); display:none; align-items:center; justify-content:center; z-index:1000; padding:16px;
    }
    .modal-content {
      background: var(--panel); padding:24px; border-radius:15px; text-align:center; border:3px solid var(--mint); max-width:92vw;
    }
    .discount-modal .modal-content { border-color: var(--danger); }
    .discount-modal h2 { color: var(--danger); margin: 0 0 10px; }
    .discount-code {
      background: var(--mint); color:#000; padding:10px 20px; border-radius:10px; font-size:1.2rem; font-weight:bold; margin:12px 0;
      user-select: all;
    }
    .claim-btn {
      background: var(--danger); border:none; color:#fff; padding:12px 20px; font-size:1rem; border-radius:18px; cursor:pointer; margin:8px;
    }
    .muted { color: var(--muted); font-size:.9rem; }
  </style>
</head>
<body>
  <div class="game-container">
    <div class="logo">SALOON <span class="nn">N&N</span></div>
    <div style="opacity:.9">Beauty Game</div>

    <div class="game-info">
      <div class="info-item">Skor: <span id="score">0</span></div>
      <div class="info-item">Level: <span id="level">1</span></div>
      <div class="info-item">Can: <span id="lives">3</span></div>
      <div class="info-item">Rekor: <span id="best">0</span></div>
    </div>

    <canvas id="gameCanvas" width="400" height="250"></canvas>

    <div class="controls" aria-label="Yön Tuşları">
      <button class="btn up"   onclick="move('up')"    aria-label="Yukarı">⬆️</button>
      <button class="btn left" onclick="move('left')"  aria-label="Sol">⬅️</button>
      <button class="btn right"onclick="move('right')" aria-label="Sağ">➡️</button>
      <button class="btn down" onclick="move('down')"  aria-label="Aşağı">⬇️</button>
    </div>

    <div class="muted">Güzellik ürünlerini topla • Stresten kaç!</div>

    <div>
      <button id="startBtn" onclick="startGame()">🎮 Oyuna Başla</button>
      <button id="pauseBtn" onclick="togglePause()" style="display:none;">⏸️ Duraklat</button>
    </div>

    <div class="website-link">
      <a href="https://saloon-nn.com" target="_blank" rel="noopener">🌐 Saloon N&N</a>
    </div>
  </div>

  <!-- Game Over -->
  <div id="gameOverModal" class="modal" role="dialog" aria-modal="true">
    <div class="modal-content">
      <h2>🏆 Oyun Bitti!</h2>
      <p style="margin:10px 0; font-size:1.1rem;">Skorunuz: <span id="finalScore" style="color:var(--mint); font-weight:bold;">0</span></p>
      <p class="muted" style="margin-top:0;">Rekor: <span id="finalBest">0</span></p>
      <div style="background: linear-gradient(45deg, var(--mint), var(--mint-dark)); padding:14px; border-radius:10px; margin:18px 0; color:#000; font-weight:bold; line-height:1.4;">
        🎉 Tebrikler! 🎉<br>
        Güzelliğinize güzellik katarak<br>
        <span style="color:#ffff00;">N&N Beauty Özel İndirimi</span> kazandınız!<br><br>
        📱 Detaylar için <strong>@saloon.nn</strong> Instagram adresimize DM!
      </div>
      <button onclick="openInstagram()" class="claim-btn">📱 Instagram'a Git</button><br/>
      <button onclick="startGame()" style="background:var(--mint); border:none; color:#000; padding:10px 20px; border-radius:15px; cursor:pointer; margin-top:8px;">🔄 Tekrar Oyna</button>
    </div>
  </div>

  <!-- Discount -->
  <div id="discountModal" class="modal discount-modal" role="dialog" aria-modal="true">
    <div class="modal-content">
      <h2>🎉 TEBRİKLER! 🎉</h2>
      <p>Seviye <span id="achievementLevel">3</span> tamamlandı!</p>
      <div class="discount-code" id="discountCode">BEAUTY25</div>
      <p class="muted">Instagram'da bu kodu göstererek indirim alın!</p>
      <button class="claim-btn" onclick="openInstagram()">📱 Instagram'da İndirim Al</button><br/>
      <button onclick="continueGame()" style="background:#666; border:none; color:#fff; padding:8px 16px; border-radius:10px; cursor:pointer; margin-top:10px;">Devam Et</button>
    </div>
  </div>

  <script>

// Çift tık zoom’u engelle
let lastTouchEnd = 0;
document.addEventListener('touchend', function (event) {
  const now = Date.now();
  if (now - lastTouchEnd <= 300) {
    event.preventDefault();
  }
  lastTouchEnd = now;
}, { passive: false });

    
    // ====== SPRITES (Twemoji SVG) ======
    const useSprites = true; // offline ya da CDN istemezsen false yap
    const SPRITES = {
      '💄': '1f484',                // lipstick
      '💅': '1f485',                // nail polish
      '🧴': '1f9f4',                // lotion bottle
      '✨': '2728',                 // sparkles
      '🧊': '1f9ca',               // ice
      '⚡': '26a1',                 // high voltage
      '🏃‍♀️': '1f3c3-200d-2640-fe0f', // woman running
      '💖': '1f496',               // sparkling heart
      '👻': '1f47b',               // ghost
      '💆‍♀️': '1f486-200d-2640-fe0f'  // woman getting massage
    };
    const spriteCache = new Map();
    function twemojiUrl(code){ return `https://twemoji.maxcdn.com/v/latest/svg/${code}.svg`; }
    async function loadSprites() {
      if (!useSprites) return;
      await Promise.all(Object.entries(SPRITES).map(([emoji, code]) => new Promise(res => {
        const img = new Image();
        img.crossOrigin = 'anonymous';
        img.onload = () => { spriteCache.set(emoji, img); res(); };
        img.onerror = () => res(); // fallback: emoji text
        img.src = twemojiUrl(code);
      })));
    }

    // ====== STATE ======
    let gameRunning = false, paused = false, powerMode = false;
    let score = 0, level = 1, lives = 3, best = Number(localStorage.getItem('nn_best')||0);
    let achievementsUnlocked = [];
    let powerTimer = null, powerEndsAt = 0;
    let spritesLoaded = false;

    const items = ['💄','💅','🧴','✨','🧊'];
    const powers = ['⚡','🏃‍♀️','💖'];
    const discounts = [
      {level:3, code:'BEAUTY25', percent:'25%'},
      {level:5, code:'SALON30',  percent:'30%'},
      {level:10, code:'PERFECT40', percent:'40%'},
      {level:15, code:'CHAMPION50', percent:'50%'}
    ];

    // ====== CANVAS & GRID ======
    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d', { alpha: false });
    const DPR = Math.max(1, Math.floor(window.devicePixelRatio || 1));
    function scaleCanvas() {
      const w = 400, h = 250; // intrinsic
      canvas.width  = w * DPR;
      canvas.height = h * DPR;
      ctx.setTransform(DPR,0,0,DPR,0,0);
    }
    scaleCanvas();

    const CELL = 20; // görünür hücre boyutu
    let ROWS = Math.floor(canvas.height / DPR / CELL);
    let COLS = Math.floor(canvas.width  / DPR / CELL);

    // ====== ENTITIES ======
    let player = { x:1, y:1, lastMove:0 };
    let enemies = [];
    let maze = []; // 0 path, 1 wall, 2 item, 3 power

    // ====== HELPERS ======
    function randInt(min, max){ return (min + Math.floor(Math.random()*(max-min+1))); }
    function canMove(x,y){ return x>=0 && x<COLS && y>=0 && y<ROWS && maze[y][x]!==1; }

    // ====== MAZE ======
    function createMaze() {
      maze = Array.from({length: ROWS}, () => Array(COLS).fill(0));
      for (let r=0;r<ROWS;r++){
        for (let c=0;c<COLS;c++){
          if (r===0||c===0||r===ROWS-1||c===COLS-1) { maze[r][c]=1; }
          else if (r%3===0 && c%3===0) { maze[r][c]=1; }
          else if ((r%6===3 && c%4===2) || (r%4===2 && c%6===3)) {
            if (Math.random()>0.3) maze[r][c]=1;
          }
        }
      }
      for (let r=1;r<ROWS-1;r++){
        for (let c=1;c<COLS-1;c++){
          if (maze[r][c]===0){
            let wallCount = (maze[r-1][c]===1) + (maze[r+1][c]===1) + (maze[r][c-1]===1) + (maze[r][c+1]===1);
            if (wallCount>=3){
              if (maze[r-1][c]===1 && r>1) maze[r-1][c]=0;
              else if (maze[r+1][c]===1 && r<ROWS-2) maze[r+1][c]=0;
              else if (maze[r][c-1]===1 && c>1) maze[r][c-1]=0;
              else if (maze[r][c+1]===1 && c<COLS-2) maze[r][c+1]=0;
            }
          }
        }
      }
      for (let r=2;r<ROWS-2;r++){
        for (let c=2;c<COLS-2;c++){
          if (maze[r][c]===0 && Math.random()<0.25){
            if (Math.abs(r-1)>2 || Math.abs(c-1)>2){
              maze[r][c] = Math.random()<0.1 ? 3 : 2;
            }
          }
        }
      }
      for (let r=1;r<=3;r++){ for (let c=1;c<=3;c++){ if (r<ROWS && c<COLS) maze[r][c]=0; } }
    }

    function itemsRemaining(){
      let n=0;
      for (let r=0;r<ROWS;r++) for (let c=0;c<COLS;c++) if (maze[r][c]===2) n++;
      return n;
    }

    // ====== ENEMIES ======
    function createEnemies() {
      enemies = [];
      const count = Math.min(4, 1 + level);
      for (let i=0;i<count;i++){
        let x,y, tries=0;
        do {
          x = randInt(1, COLS-2); y = randInt(1, ROWS-2); tries++;
        } while ((maze[y][x]!==0 || (x<=3 && y<=3)) && tries<100);
        if (tries<100){
          enemies.push({
            x,y, dir: randInt(0,3), lastMove:0,
            color: ['#e74c3c','#e67e22','#9b59b6','#f39c12'][i%4]
          });
        }
      }
    }

    function enemyTickInterval() {
      const base = 420, perLevel = 22, minMs = 120;
      return Math.max(minMs, base - level * perLevel);
    }

    function moveEnemies() {
      if (!gameRunning || paused) return;
      const interval = enemyTickInterval();
      for (const enemy of enemies){
        const now = performance.now();
        if (now - enemy.lastMove < interval) continue;

        const moves = [
          {dir:0, x:0, y:-1}, {dir:1, x:0, y:1},
          {dir:2, x:-1, y:0}, {dir:3, x:1, y:0}
        ];
        let best=null, bestDist = powerMode ? -1 : 1e9;

        for (const mv of moves){
          const nx = enemy.x + mv.x, ny = enemy.y + mv.y;
          if (!canMove(nx,ny)) continue;
          const dx = player.x - nx, dy = player.y - ny;
          const d = Math.hypot(dx,dy);
          if (powerMode) { if (d > bestDist){ bestDist = d; best = mv; } }
          else { if (d < bestDist){ bestDist = d; best = mv; } }
        }
        if (best){
          enemy.x += best.x; enemy.y += best.y; enemy.dir = best.dir;
        } else {
          for (const mv of moves){
            const nx = enemy.x + mv.x, ny = enemy.y + mv.y;
            if (canMove(nx,ny)){ enemy.x = nx; enemy.y = ny; enemy.dir = mv.dir; break; }
          }
        }
        enemy.lastMove = now;
      }
    }

    // ====== INPUT ======
    function move(direction){
      if (!gameRunning || paused) return;
      let nx = player.x, ny = player.y;
      if (direction==='up') ny--;
      if (direction==='down') ny++;
      if (direction==='left') nx--;
      if (direction==='right') nx++;
      if (canMove(nx,ny)){
        player.x = nx; player.y = ny;

        if (maze[ny][nx]===2){ score += 10; maze[ny][nx]=0; }
        else if (maze[ny][nx]===3){ activatePower(3500); maze[ny][nx]=0; }

        checkCollisions();
        if (itemsRemaining()===0){
          level++; checkAchievements(); initLevel();
        }
        updateUI();
      }
    }

    window.addEventListener('keydown', (e)=>{
      const k = e.key.toLowerCase();
      if (['arrowup','arrowdown','arrowleft','arrowright','w','a','s','d'].includes(k)) e.preventDefault();
      if (k==='arrowup'||k==='w') move('up');
      else if (k==='arrowdown'||k==='s') move('down');
      else if (k==='arrowleft'||k==='a') move('left');
      else if (k==='arrowright'||k==='d') move('right');
      else if (k==='p') togglePause();
    }, {passive:false});

    (function addSwipe(el){
      let sx=0, sy=0, t=false;
      el.addEventListener('touchstart',e=>{ if(!e.touches[0])return; t=true; sx=e.touches[0].clientX; sy=e.touches[0].clientY; },{passive:true});
      el.addEventListener('touchend',e=>{
        if(!t) return; t=false;
        const dx=(e.changedTouches[0].clientX - sx), dy=(e.changedTouches[0].clientY - sy);
        if (Math.hypot(dx,dy) < 20) return;
        if (Math.abs(dx) > Math.abs(dy)) move(dx>0?'right':'left'); else move(dy>0?'down':'up');
      },{passive:true});
    })(canvas);

    // ====== POWER MODE (extend) ======
    function activatePower(durationMs){
      const now = performance.now();
      const remaining = Math.max(0, powerEndsAt - now);
      powerEndsAt = now + durationMs + remaining;
      powerMode = true;
      if (powerTimer) clearInterval(powerTimer);
      powerTimer = setInterval(()=>{
        if (performance.now() >= powerEndsAt){
          powerMode = false; clearInterval(powerTimer); powerTimer = null;
        }
      }, 50);
    }

    // ====== COLLISIONS ======
    function checkCollisions(){
      for (let i=enemies.length-1;i>=0;i--){
        const e = enemies[i];
        if (e.x===player.x && e.y===player.y){
          if (powerMode){
            enemies.splice(i,1);
            score += 50;
          } else {
            lives--;
            player.x=1; player.y=1;
            for (const g of enemies){
              do { g.x = randInt(2,COLS-3); g.y=randInt(2,ROWS-3); }
              while (maze[g.y][g.x]!==0);
            }
            if (lives<=0){ return gameOver(); }
          }
        }
      }
    }

    // ====== ACHIEVEMENTS ======
    function checkAchievements(){
      const d = discounts.find(d=>d.level===level);
      if (d && !achievementsUnlocked.includes(level)){
        achievementsUnlocked.push(level);
        showDiscount(d);
      }
    }
    function showDiscount(d){
      document.getElementById('achievementLevel').textContent = d.level;
      document.getElementById('discountCode').textContent = d.code;
      document.getElementById('discountModal').style.display = 'flex';
      gameRunning = false;
    }
    function continueGame(){
      document.getElementById('discountModal').style.display = 'none';
      gameRunning = true;
    }

    // ====== FLOW ======
    async function startGame(){
      if (!spritesLoaded) { await loadSprites(); spritesLoaded = true; }
      score=0; level=1; lives=3; achievementsUnlocked=[]; powerMode=false;
      document.getElementById('startBtn').style.display='none';
      document.getElementById('gameOverModal').style.display='none';
      document.getElementById('discountModal').style.display='none';
      document.getElementById('pauseBtn').style.display='inline-block';
      document.getElementById('pauseBtn').textContent='⏸️ Duraklat';
      paused=false;
      initLevel(); updateUI();
      gameRunning = true;
    }
    function togglePause(){
      if (!gameRunning) return;
      paused = !paused;
      document.getElementById('pauseBtn').textContent = paused ? '▶️ Devam' : '⏸️ Duraklat';
    }
    function initLevel(){
      createMaze(); createEnemies(); player.x=1; player.y=1;
    }
    function gameOver(){
      gameRunning=false; paused=false;
      document.getElementById('pauseBtn').style.display='none';
      document.getElementById('finalScore').textContent = score;
      best = Math.max(best, score); localStorage.setItem('nn_best', String(best));
      document.getElementById('finalBest').textContent = best;
      document.getElementById('gameOverModal').style.display='flex';
      document.getElementById('startBtn').style.display='inline-block';
      updateUI();
    }

    function openInstagram(){
      window.open('https://www.instagram.com/saloon.nn?igsh=Nm91bDZvYWhvOWlw','_blank','noopener');
    }

    function updateUI(){
      document.getElementById('score').textContent = score;
      document.getElementById('level').textContent = level;
      document.getElementById('lives').textContent = lives;
      document.getElementById('best').textContent  = best;
    }

    // ====== DRAW HELPERS (sprites) ======
    function drawSpriteOrEmoji(emoji, x, y, sizePx) {
      const img = spriteCache.get(emoji);
      if (img) {
        const s = sizePx;
        ctx.imageSmoothingEnabled = true;
        ctx.drawImage(img, x - s/2, y - s/2, s, s);
      } else {
        ctx.font = `${Math.floor(sizePx*0.9)}px Arial`;
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        ctx.fillStyle = '#fff';
        ctx.fillText(emoji, x, y+1);
      }
    }
    function drawItemAt(emoji, cellX, cellY){
      const cx = cellX*CELL + CELL/2, cy = cellY*CELL + CELL/2;
      drawSpriteOrEmoji(emoji, cx, cy, Math.min(18, CELL*0.9));
    }
    function drawPowerAt(emoji, cellX, cellY){
      const cx = cellX*CELL + CELL/2, cy = cellY*CELL + CELL/2;
      drawSpriteOrEmoji(emoji, cx, cy, Math.min(20, CELL*0.95));
    }
    function drawGhostAt(enemy){
      const ex = enemy.x*CELL + CELL/2, ey = enemy.y*CELL + CELL/2;
      if (powerMode) {
        ctx.fillStyle='#666';
        ctx.beginPath(); ctx.arc(ex,ey,5,0,Math.PI*2); ctx.fill();
        drawSpriteOrEmoji('👻', ex, ey, 12);
      } else {
        ctx.shadowColor = enemy.color; ctx.shadowBlur = 8;
        ctx.fillStyle = enemy.color;
        ctx.beginPath(); ctx.arc(ex,ey,7,0,Math.PI*2); ctx.fill();
        ctx.shadowBlur = 0;
        drawSpriteOrEmoji('👻', ex, ey, 12);
      }
    }
    function drawPlayer(){
      const px = player.x*CELL + CELL/2, py = player.y*CELL + CELL/2;
      ctx.fillStyle = powerMode ? '#ffff00' : '#ff6b9d';
      ctx.beginPath(); ctx.arc(px,py,8,0,Math.PI*2); ctx.fill();
      drawSpriteOrEmoji('💆‍♀️', px, py, 14);
    }

    // ====== RENDER ======
    function draw(){
      ctx.fillStyle='#000'; ctx.fillRect(0,0,canvas.width/DPR,canvas.height/DPR);

      // watermark
      ctx.save(); ctx.globalAlpha=0.08; ctx.fillStyle='#4ecdc4';
      ctx.font='30px Arial'; ctx.textAlign='center'; ctx.textBaseline='alphabetic';
      ctx.fillText('N&N', (canvas.width/DPR)/2, (canvas.height/DPR)/2); ctx.restore();

      if (!gameRunning){
        ctx.fillStyle='#4ecdc4'; ctx.font='bold 20px Arial'; ctx.textAlign='center'; ctx.textBaseline='alphabetic';
        ctx.fillText('SALOON N&N', (canvas.width/DPR)/2, (canvas.height/DPR)/2 - 40);
        ctx.fillStyle='#fff'; ctx.font='14px Arial';
        ctx.fillText('Beauty Game', (canvas.width/DPR)/2, (canvas.height/DPR)/2 - 15);
        ctx.font='12px Arial';
        ctx.fillText('🎯 Güzellik ürünlerini topla', (canvas.width/DPR)/2, (canvas.height/DPR)/2 + 10);
        ctx.fillText('👻 Hayaletlerden kaç', (canvas.width/DPR)/2, (canvas.height/DPR)/2 + 30);
        return;
      }

      // maze (daha net kontur)
      for (let r=0;r<ROWS;r++){
        for (let c=0;c<COLS;c++){
          const x=c*CELL, y=r*CELL;
          if (maze[r][c]===1){
            ctx.fillStyle = '#193f42';
            ctx.fillRect(x,y,CELL,CELL);
            ctx.strokeStyle = '#4ecdc4';
            ctx.lineWidth = 2;
            ctx.strokeRect(x+1,y+1,CELL-2,CELL-2);
          } else if (maze[r][c]===2){
            const it = items[(r+c)%items.length];
            drawItemAt(it, c, r);
          } else if (maze[r][c]===3){
            const pw = powers[(r+c)%powers.length];
            drawPowerAt(pw, c, r);
          }
        }
      }

      // player + enemies
      drawPlayer();
      for (const enemy of enemies) drawGhostAt(enemy);
    }

    // ====== LOOP ======
    function tick(){
      if (gameRunning && !paused){
        moveEnemies();
        checkCollisions();
      }
      draw();
      requestAnimationFrame(tick);
    }
    draw(); tick();

    // modal dışına tıklayınca kapatma (discount)
    for (const id of ['discountModal']){
      const m = document.getElementById(id);
      m.addEventListener('click', (e)=>{ if (e.target===m){ continueGame(); } });
    }

    // (opsiyonel) farklı DPR değişimlerinde yeniden ölçekleme
    // Not: bazı tarayıcılarda matchMedia 'change' desteklemez; sorun değil.
    try {
      const mm = window.matchMedia(`(resolution: ${DPR}dppx)`);
      mm.addEventListener && mm.addEventListener('change', scaleCanvas);
    } catch(_){}
  </script>
</body>
</html>


